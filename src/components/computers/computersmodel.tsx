// @ts-nocheck
'use client';

import * as THREE from 'three';
import {
  useMemo,
  useContext,
  createContext,
  useRef,
  useState,
  useEffect,
} from 'react';
import { useFrame } from '@react-three/fiber';
import {
  useGLTF,
  Merged,
  RenderTexture,
  PerspectiveCamera,
  Text,
  useCursor,
  useScroll,
  useTexture,
  Html,
} from '@react-three/drei';
THREE.ColorManagement.legacyMode = false;
// import TwistedBox from '@/components/demo/Shader/TwistedBox';
/*
The following was auto-generated by: npx gltfjsx computers.glb --transform --instance
By using the --instance flag it detects similar geometry and instances it, thereby minimizing draw-calls

Author: Rafael Rodrigues (https://sketchfab.com/RafaelBR873D)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/old-computers-7bb6e720499a467b8e0427451d180063
Title: Old Computers
*/

// 整合SpinningBox组件到当前文件
function SpinningBox({ scale = 1, position, ...props }) {
  // This reference gives us direct access to the THREE.Mesh object
  const ref = useRef();
  // Hold state for hovered and clicked events
  const [hovered, hover] = useState(false);
  const [clicked, click] = useState(false);
  useCursor(hovered);

  // Subscribe this component to the render-loop, rotate the mesh every frame
  useFrame((state, delta) => {
    if (ref.current) {
      ref.current.rotation.x = ref.current.rotation.y += delta;
    }
  });

  // Return the view, these are regular Threejs elements expressed in JSX
  return (
    <mesh
      {...props}
      ref={ref}
      scale={clicked ? scale * 1.4 : scale}
      onClick={(event) => {
        // 阻止事件冒泡以避免重复触发
        event.stopPropagation();
        click(!clicked);
      }}
      onPointerOver={(event) => hover(true)}
      onPointerOut={(event) => hover(false)}
      position={position}
    >
      <boxGeometry />

      <meshStandardMaterial
        wireframe={true}
        color={hovered ? 'hotpink' : 'indianred'}
      />
    </mesh>
  );
}

const context = createContext<any>(null);
export function Instances({
  children,
  ...props
}: {
  children: React.ReactNode;
  [key: string]: any;
}) {
  const { nodes } = useGLTF('/models/computers_1-transformed.glb');
  const instances = useMemo(
    () => ({
      Object: nodes.Object_4,
      Object1: nodes.Object_16,
      Object3: nodes.Object_52,
      Object13: nodes.Object_172,
      Object14: nodes.Object_174,
      Object23: nodes.Object_22,
      Object24: nodes.Object_26,
      Object32: nodes.Object_178,
      Object36: nodes.Object_28,
      Object45: nodes.Object_206,
      Object46: nodes.Object_207,
      Object47: nodes.Object_215,
      Object48: nodes.Object_216,
      Sphere: nodes.Sphere,
    }),
    [nodes],
  );
  return (
    <Merged castShadow receiveShadow meshes={instances} {...props}>
      {(instances) => (
        <context.Provider value={instances}>{children}</context.Provider>
      )}
    </Merged>
  );
}

export function Computers(props: any) {
  const { nodes: n, materials: m } = useGLTF(
    '/models/computers_1-transformed.glb',
  );
  const instances = useContext(context);
  return (
    <group {...props} dispose={null}>
      <instances.Object
        position={[0.16, 0.79, -1.97]}
        rotation={[-0.54, 0.93, -1.12]}
        scale={0.5}
      />
      <instances.Object
        position={[-2.79, 0.27, 1.82]}
        rotation={[-1.44, 1.22, 1.43]}
        scale={0.5}
      />
      <instances.Object
        position={[-5.6, 4.62, -0.03]}
        rotation={[-1.96, 0.16, 1.2]}
        scale={0.5}
      />
      <instances.Object
        position={[2.62, 1.98, -2.47]}
        rotation={[-0.42, -0.7, -1.85]}
        scale={0.5}
      />
      <instances.Object
        position={[4.6, 3.46, 1.19]}
        rotation={[-1.24, -0.72, 0.48]}
        scale={0.5}
      />
      <instances.Object1
        position={[0.63, 0, -3]}
        rotation={[0, 0.17, 0]}
        scale={1.52}
      />
      <instances.Object1
        position={[-2.36, 0.32, -2.02]}
        rotation={[0, 0.53, -Math.PI / 2]}
        scale={1.52}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={n.Object_24.geometry}
        material={m.Texture}
        position={[-2.42, 0.94, -2.25]}
        rotation={[0, 0.14, Math.PI / 2]}
        scale={-1.52}
      />
      <instances.Object1
        position={[-3.53, 0, 0.59]}
        rotation={[Math.PI, -1.09, Math.PI]}
        scale={1.52}
      />
      <instances.Object1
        position={[-3.53, 1.53, 0.59]}
        rotation={[0, 0.91, 0]}
        scale={1.52}
      />
      <instances.Object1
        position={[3.42, 0, 0]}
        rotation={[-Math.PI, 1.13, -Math.PI]}
        scale={1.52}
      />
      <instances.Object1
        position={[4.09, 2.18, 2.41]}
        rotation={[0, -1.55, 1.57]}
        scale={1.52}
      />
      <instances.Object3
        position={[4.31, 1.57, 2.34]}
        rotation={[0, -1.15, -Math.PI / 2]}
        scale={-1.52}
      />
      <instances.Object3
        position={[-3.79, 0, 1.66]}
        rotation={[Math.PI, -1.39, 0]}
        scale={-1.52}
      />
      <instances.Object3
        position={[-3.79, 1.53, 1.66]}
        rotation={[0, 1.22, -Math.PI]}
        scale={-1.52}
      />
      <instances.Object1
        position={[-3.69, 0, 2.59]}
        rotation={[0, -1.57, 0]}
        scale={1.52}
      />
      <instances.Object1
        position={[-5.36, 2.18, 0.81]}
        rotation={[0, 0.77, Math.PI / 2]}
        scale={1.52}
      />
      <instances.Object3
        position={[-5.56, 1.57, 0.69]}
        rotation={[0, 1.17, -Math.PI / 2]}
        scale={-1.52}
      />
      <instances.Object1
        position={[-5.47, 2.79, 0.74]}
        rotation={[Math.PI, -1.16, Math.PI / 2]}
        scale={1.52}
      />
      <instances.Object3
        position={[-5.29, 3.41, 0.89]}
        rotation={[Math.PI, -0.76, -Math.PI / 2]}
        scale={-1.52}
      />
      <instances.Object1
        position={[-5.28, 0, -2.33]}
        rotation={[0, 0.75, 0]}
        scale={1.52}
      />
      <instances.Object1
        position={[-5.49, 0, -1.38]}
        rotation={[Math.PI, -0.99, Math.PI]}
        scale={1.52}
      />
      <instances.Object1
        position={[-3.01, 0, -3.79]}
        rotation={[0, 0.6, 0]}
        scale={1.52}
      />
      <instances.Object1
        position={[-2.08, 0, -4.32]}
        rotation={[Math.PI, -0.6, Math.PI]}
        scale={1.52}
      />
      <instances.Object1
        position={[-1.02, 0, -4.49]}
        rotation={[0, 0.31, 0]}
        scale={1.52}
      />
      <instances.Object1
        position={[-5.31, 1.83, -1.41]}
        rotation={[0, 1.06, Math.PI / 2]}
        scale={1.52}
      />
      <instances.Object1
        position={[-4.18, 1.83, -3.06]}
        rotation={[-Math.PI, -0.46, -Math.PI / 2]}
        scale={1.52}
      />
      <instances.Object1
        position={[-1.76, 1.83, -3.6]}
        rotation={[0, -1.16, Math.PI / 2]}
        scale={1.52}
      />
      <instances.Object1
        position={[-0.25, 1.83, -5.54]}
        rotation={[0, 1.55, 1.57]}
        scale={1.52}
      />
      <instances.Object1
        position={[-5.28, 2.14, -2.33]}
        rotation={[Math.PI, -0.75, Math.PI]}
        scale={1.52}
      />
      <instances.Object1
        position={[-5.49, 2.14, -1.38]}
        rotation={[0, 0.99, 0]}
        scale={1.52}
      />
      <instances.Object1
        position={[-3.01, 2.14, -3.79]}
        rotation={[Math.PI, -0.6, Math.PI]}
        scale={1.52}
      />
      <instances.Object1
        position={[-2.08, 2.14, -4.32]}
        rotation={[0, 0.6, 0]}
        scale={1.52}
      />
      <instances.Object1
        position={[-1.02, 2.14, -4.49]}
        rotation={[Math.PI, -0.31, Math.PI]}
        scale={1.52}
      />
      <instances.Object1
        position={[-5.31, 3.98, -1.41]}
        rotation={[0, 1.06, Math.PI / 2]}
        scale={1.52}
      />
      <instances.Object1
        position={[-4.18, 3.98, -3.06]}
        rotation={[-Math.PI, -0.46, -Math.PI / 2]}
        scale={1.52}
      />
      <instances.Object1
        position={[-1.17, 3.98, -4.45]}
        rotation={[0, 0.17, Math.PI / 2]}
        scale={1.52}
      />
      <instances.Object1
        position={[-0.94, 3.98, -4.66]}
        rotation={[Math.PI, 0.02, -Math.PI / 2]}
        scale={1.52}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={n.Object_140.geometry}
        material={m.Texture}
        position={[5.53, 2.18, 0.17]}
        rotation={[-Math.PI, 0, 0]}
        scale={-1}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={n.Object_144.geometry}
        material={m.Texture}
        position={[5.74, 1.57, 0.05]}
        rotation={[-Math.PI, 0, 0]}
        scale={-1}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={n.Object_148.geometry}
        material={m.Texture}
        position={[5.65, 2.79, 0.11]}
        rotation={[-Math.PI, 0, 0]}
        scale={-1}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={n.Object_152.geometry}
        material={m.Texture}
        position={[5.46, 3.41, 0.26]}
        rotation={[-Math.PI, 0, 0]}
        scale={-1}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={n.Object_156.geometry}
        material={m.Texture}
        position={[4.86, 0, -2.54]}
        rotation={[-Math.PI, 0, 0]}
        scale={-1}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={n.Object_160.geometry}
        material={m.Texture}
        position={[5.06, 0, -1.6]}
        rotation={[-Math.PI, 0, 0]}
        scale={-1}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={n.Object_164.geometry}
        material={m.Texture}
        position={[2.59, 0, -4]}
        rotation={[-Math.PI, 0, 0]}
        scale={-1}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={n.Object_168.geometry}
        material={m.Texture}
        position={[1.66, 0, -4.54]}
        rotation={[-Math.PI, 0, 0]}
        scale={-1}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={n.Object_170.geometry}
        material={m.Texture}
        position={[0.59, 0, -4.7]}
        rotation={[-Math.PI, 0, 0]}
        scale={-1}
      />
      <instances.Object13
        position={[4.89, 1.83, -1.62]}
        rotation={[-Math.PI, 0, 0]}
        scale={-1}
      />
      <instances.Object14
        position={[3.75, 1.83, -3.28]}
        rotation={[-Math.PI, 0, 0]}
        scale={-1}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={n.Object_176.geometry}
        material={m.Texture}
        position={[1.33, 1.83, -3.82]}
        rotation={[-Math.PI, 0, 0]}
        scale={-1}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={n.Object_180.geometry}
        material={m.Texture}
        position={[4.86, 2.14, -2.54]}
        rotation={[-Math.PI, 0, 0]}
        scale={-1}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={n.Object_184.geometry}
        material={m.Texture}
        position={[5.06, 2.14, -1.6]}
        rotation={[-Math.PI, 0, 0]}
        scale={-1}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={n.Object_188.geometry}
        material={m.Texture}
        position={[2.59, 2.14, -4]}
        rotation={[-Math.PI, 0, 0]}
        scale={-1}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={n.Object_192.geometry}
        material={m.Texture}
        position={[1.66, 2.14, -4.54]}
        rotation={[-Math.PI, 0, 0]}
        scale={-1}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={n.Object_194.geometry}
        material={m.Texture}
        position={[0.59, 2.14, -4.7]}
        rotation={[-Math.PI, 0, 0]}
        scale={-1}
      />
      <instances.Object13
        position={[4.89, 3.98, -1.62]}
        rotation={[-Math.PI, 0, 0]}
        scale={-1}
      />
      <instances.Object14
        position={[3.75, 3.98, -3.28]}
        rotation={[-Math.PI, 0, 0]}
        scale={-1}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={n.Object_200.geometry}
        material={m.Texture}
        position={[0.75, 3.98, -4.66]}
        rotation={[-Math.PI, 0, 0]}
        scale={-1}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={n.Object_18.geometry}
        material={m.Texture}
        position={[-0.19, 0, -2.96]}
        rotation={[0, -0.06, 0]}
        scale={1.52}
      />
      <instances.Object23
        position={[-2.29, 1.56, -2.26]}
        rotation={[0, -0.005, -Math.PI / 2]}
        scale={1.52}
      />
      <instances.Object24
        position={[-2.19, 2.19, -1.87]}
        rotation={[0, 0.51, Math.PI / 2]}
        scale={-1.52}
      />
      <instances.Object23
        position={[-2.9, 0.3, -1.47]}
        rotation={[Math.PI, -1.35, Math.PI / 2]}
        scale={1.52}
      />
      <instances.Object23
        position={[3.22, 0, -0.8]}
        rotation={[0, -1.32, 0]}
        scale={1.52}
      />
      <instances.Object23
        position={[3.53, 1.83, 0.44]}
        rotation={[-Math.PI, 1.32, Math.PI / 2]}
        scale={1.52}
      />
      <instances.Object23
        position={[4.26, 0.94, 2.22]}
        rotation={[0, -1, Math.PI / 2]}
        scale={1.52}
      />
      <instances.Object24
        position={[3.87, 0.32, 2.35]}
        rotation={[0, -1.53, -1.57]}
        scale={-1.52}
      />
      <instances.Object23
        position={[-5.61, 0.94, 0.82]}
        rotation={[0, 1.32, 1.57]}
        scale={1.52}
      />
      <instances.Object24
        position={[-5.26, 0.32, 1.01]}
        rotation={[0, 0.79, -Math.PI / 2]}
        scale={-1.52}
      />
      <instances.Object23
        position={[-5.39, 4.03, 0.99]}
        rotation={[Math.PI, -0.61, Math.PI / 2]}
        scale={1.52}
      />
      <instances.Object24
        position={[-5.7, 4.66, 0.72]}
        rotation={[Math.PI, -1.13, -Math.PI / 2]}
        scale={-1.52}
      />
      <instances.Object23
        position={[-5.95, 0, -0.64]}
        rotation={[0, 0.95, 0]}
        scale={1.52}
      />
      <instances.Object23
        position={[-4.48, 0, -2.75]}
        rotation={[Math.PI, -0.57, Math.PI]}
        scale={1.52}
      />
      <instances.Object23
        position={[-3.72, 0, -2.89]}
        rotation={[0, 0.64, 0]}
        scale={1.52}
      />
      <instances.Object23
        position={[-0.08, 0, -5.03]}
        rotation={[Math.PI, -0.04, Math.PI]}
        scale={1.52}
      />
      <instances.Object24
        position={[-4.19, 1.84, -2.77]}
        rotation={[Math.PI, -0.66, -Math.PI / 2]}
        scale={-1.52}
      />
      <instances.Object23
        position={[-5.95, 2.14, -0.64]}
        rotation={[Math.PI, -0.95, Math.PI]}
        scale={1.52}
      />
      <instances.Object23
        position={[-4.48, 2.14, -2.75]}
        rotation={[0, 0.57, 0]}
        scale={1.52}
      />
      <instances.Object23
        position={[-3.73, 2.14, -3.1]}
        rotation={[Math.PI, -0.64, Math.PI]}
        scale={1.52}
      />
      <instances.Object23
        position={[-0.08, 2.14, -5.03]}
        rotation={[0, 0.04, 0]}
        scale={1.52}
      />
      <instances.Object24
        position={[-4.19, 3.98, -2.77]}
        rotation={[Math.PI, -0.66, -Math.PI / 2]}
        scale={-1.52}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={n.Object_142.geometry}
        material={m.Texture}
        position={[5.79, 0.94, 0.18]}
        rotation={[-Math.PI, 0, 0]}
        scale={-1}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={n.Object_146.geometry}
        material={m.Texture}
        position={[5.43, 0.32, 0.37]}
        rotation={[-Math.PI, 0, 0]}
        scale={-1}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={n.Object_150.geometry}
        material={m.Texture}
        position={[5.56, 4.03, 0.35]}
        rotation={[-Math.PI, 0, 0]}
        scale={-1}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={n.Object_154.geometry}
        material={m.Texture}
        position={[5.87, 4.66, 0.08]}
        rotation={[-Math.PI, 0, 0]}
        scale={-1}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={n.Object_158.geometry}
        material={m.Texture}
        position={[5.53, 0, -0.85]}
        rotation={[-Math.PI, 0, 0]}
        scale={-1}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={n.Object_162.geometry}
        material={m.Texture}
        position={[4.05, 0, -2.96]}
        rotation={[-Math.PI, 0, 0]}
        scale={-1}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={n.Object_166.geometry}
        material={m.Texture}
        position={[3.29, 0, -3.1]}
        rotation={[-Math.PI, 0, 0]}
        scale={-1}
      />
      <instances.Object32
        position={[3.77, 1.84, -2.98]}
        rotation={[-Math.PI, 0, 0]}
        scale={-1}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={n.Object_182.geometry}
        material={m.Texture}
        position={[5.53, 2.14, -0.85]}
        rotation={[-Math.PI, 0, 0]}
        scale={-1}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={n.Object_186.geometry}
        material={m.Texture}
        position={[4.05, 2.14, -2.96]}
        rotation={[-Math.PI, 0, 0]}
        scale={-1}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={n.Object_190.geometry}
        material={m.Texture}
        position={[3.3, 2.14, -3.31]}
        rotation={[-Math.PI, 0, 0]}
        scale={-1}
      />
      <instances.Object32
        position={[3.77, 3.98, -2.98]}
        rotation={[-Math.PI, 0, 0]}
        scale={-1}
      />
      <instances.Object36
        position={[0.35, 2.35, -3.34]}
        rotation={[-0.26, 0, 0]}
      />
      <instances.Object36
        position={[0.18, 2.8, -2.85]}
        rotation={[0.09, 0.15, -0.005]}
      />
      <instances.Object36
        position={[1.89, 0, -1.94]}
        rotation={[0, -0.44, 0]}
        scale={[1.5, 1, 1.5]}
      />
      <instances.Object36
        position={[1.86, 1.61, -1.81]}
        rotation={[0, -Math.PI / 3, 0]}
      />
      <instances.Object36
        position={[3.95, 2.49, 1.61]}
        rotation={[0, -Math.PI / 3, 0]}
      />
      <instances.Object36
        position={[-1.1, 4.29, -4.43]}
        rotation={[0, 0.36, 0]}
      />
      <instances.Object36
        position={[-5.25, 4.29, -1.47]}
        rotation={[0, 1.25, 0]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={n.Object_204.geometry}
        material={m.Texture}
        position={[3.2, 4.29, -3.09]}
        rotation={[-Math.PI, 0.56, 0]}
        scale={-1}
      />

      <ScreenInteractive //blue screen
        frame="Object_206"
        panel="Object_207"
        position={[0.27, 1.53, -2.61]}
      />

      <ScreenText
        frame="Object_209"
        panel="Object_210"
        y={5}
        position={[-1.43, 2.5, -1.8]}
        rotation={[0, 1, 0]}
      />
      <ScreenText
        invert
        frame="Object_212"
        panel="Object_213"
        x={-5}
        y={5}
        position={[-2.73, 0.63, -0.52]}
        rotation={[0, 1.09, 0]}
      />
      <ScreenText
        invert
        frame="Object_215"
        panel="Object_216"
        position={[1.84, 0.38, -1.77]}
        rotation={[0, -Math.PI / 9, 0]}
      />
      <ScreenText
        invert
        frame="Object_218"
        panel="Object_219"
        x={-5}
        position={[3.11, 2.15, -0.18]}
        rotation={[0, -0.79, 0]}
        scale={0.81}
      />
      <ScreenText
        frame="Object_221"
        panel="Object_222"
        y={5}
        position={[-3.42, 3.06, 1.3]}
        rotation={[0, 1.22, 0]}
        scale={0.9}
      />
      <ScreenText
        invert
        frame="Object_224"
        panel="Object_225"
        position={[-3.9, 4.29, -2.64]}
        rotation={[0, 0.54, 0]}
      />
      <ScreenText
        frame="Object_227"
        panel="Object_228"
        position={[0.96, 4.28, -4.2]}
        rotation={[0, -0.65, 0]}
      />
      <ScreenText
        frame="Object_230"
        panel="Object_231"
        position={[4.68, 4.29, -1.56]}
        rotation={[0, -Math.PI / 3, 0]}
      />
      <Leds instances={instances} />
    </group>
  );
}

/* This component renders a monitor (taken out of the gltf model)
   It renders a custom scene into a texture and projects it onto monitors screen */
function Screen({
  frame,
  panel,
  children,
  ...props
}: {
  frame: string;
  panel: string;
  children: React.ReactNode;
  [key: string]: any;
}) {
  const { nodes, materials } = useGLTF('/models/computers_1-transformed.glb');
  return (
    <group {...props}>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes[frame].geometry}
        material={materials.Texture}
      />
      <mesh geometry={nodes[panel].geometry}>
        <meshBasicMaterial toneMapped={false}>
          <RenderTexture
            width={2560}
            height={2560}
            attach="map"
            anisotropy={16}
          >
            {children}
          </RenderTexture>
        </meshBasicMaterial>
      </mesh>
    </group>
  );
}

/* Renders a monitor with some text */
function ScreenText({ invert, x = 0, y = 1.3, ...props }) {
  const textRef = useRef();
  const rand = Math.random() * 10000;
  useFrame(
    (state) =>
      (textRef.current.position.x =
        x + Math.sin(rand + state.clock.elapsedTime / 4) * 12),
  );
  return (
    <Screen {...props}>
      <PerspectiveCamera
        makeDefault
        manual
        aspect={1 / 1}
        position={[0, 0, 15]}
      />
      <color attach="background" args={[invert ? 'black' : '#35cc00']} />
      <ambientLight intensity={2.5} />
      <directionalLight position={[10, 10, 5]} intensity={1} />
      <Text
        position={[x, y, 0]}
        ref={textRef}
        font="/Optician-Sans.woff"
        fontSize={3}
        letterSpacing={0}
        color={!invert ? 'black' : '#35cc00'}
      >
        ?WHO3
      </Text>
    </Screen>
  );
}

/* Renders a monitor with different content based on scroll position */
function ScreenInteractive(props: any) {
  const [content, setContent] = useState(0);
  const [prevContent, setPrevContent] = useState(0);
  const [isChanging, setIsChanging] = useState(false);
  const scroll = useScroll();
  const noiseRef = useRef();
  const audioRef = useRef(null);
  const transitionTimeoutRef = useRef(null);

  // 创建音频元素
  useEffect(() => {
    // 创建音频元素并预加载
    const audio = new Audio('/sounds/tvsound.mp3'); // 使用已下载的音频文件
    audio.load(); // 预加载音频
    audio.volume = 0.2; // 设置音量
    audioRef.current = audio;

    return () => {
      // 清理
      if (audioRef.current) {
        // 确保音频停止播放并移除引用
        try {
          audioRef.current.pause();
          audioRef.current.src = '';
        } catch (e) {
          console.log('Audio cleanup error:', e);
        }
        audioRef.current = null;
      }

      if (transitionTimeoutRef.current) {
        clearTimeout(transitionTimeoutRef.current);
        transitionTimeoutRef.current = null;
      }
    };
  }, []);

  // 播放切换动画
  const startChannelChangeAnimation = (newContent) => {
    if (prevContent === newContent) return;

    setIsChanging(true);
    playChannelChangeSound();

    // 清除之前的定时器（如果存在）
    if (transitionTimeoutRef.current) {
      clearTimeout(transitionTimeoutRef.current);
    }

    // 动画持续时间
    transitionTimeoutRef.current = setTimeout(() => {
      setPrevContent(newContent);
      setIsChanging(false);
      transitionTimeoutRef.current = null;
    }, 700); // 缩短切换动画时间为700ms
  };

  // 电视噪点材质
  const noiseMaterial = useMemo(() => {
    return new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0 },
      },
      transparent: true,
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        varying vec2 vUv;
        uniform float time;
        
        float random(vec2 st) {
          return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
        }
        
        void main() {
          vec2 st = vUv;
          
          // 复古CRT效果 - 扭曲uv坐标
          float distortion = 0.2;
          vec2 cc = st - 0.5;
          float dist = dot(cc, cc) * distortion;
          st = st + cc * (1.0 + dist) * dist;
          
          // 淡绿色调
          vec3 baseColor = vec3(0.1, 0.2, 0.1);
          
          // 降低整体亮度的噪点
          float r = random(st + time * 0.1);
          vec3 color = baseColor + vec3(r) * 0.5;
          
          // 暗化边缘 (复古电视的晕影效果)
          float vignette = smoothstep(0.8, 0.2, length(st - 0.5)) * 0.5;
          color = mix(color, vec3(0.0, 0.01, 0.0), vignette);
          
          // 添加水平扫描线
          float scanline1 = sin(st.y * 120.0) * 0.03 + 1.0;
          // 添加垂直扫描线 (较弱)
          float scanline2 = sin(st.x * 30.0) * 0.01 + 1.0;
          color *= scanline1 * scanline2;
          
          // 随机亮白点 (电视噪点)
          if (random(st + time) > 0.992) {
            color = vec3(0.3, 0.7, 0.3);
          }
          
          // 使用较高的不透明度但使整体效果更暗
          gl_FragColor = vec4(color, 0.90);
        }
      `,
    });
  }, []);

  // 安全播放切换声音
  const playChannelChangeSound = () => {
    if (audioRef.current) {
      try {
        // 重置音频并播放
        audioRef.current.currentTime = 0;

        // 使用Promise捕获播放错误，但不阻止程序执行
        const playPromise = audioRef.current.play();
        if (playPromise !== undefined) {
          playPromise.catch((error) => {
            // 忽略AbortError，因为它通常是由于组件卸载引起的
            if (error.name !== 'AbortError') {
              console.log('Audio play failed:', error);
            }
          });
        }
      } catch (e) {
        console.log('Audio play error:', e);
      }
    }
  };

  // 监听滚动位置并更新内容
  useFrame(({ clock }) => {
    const offset = scroll.offset;
    // 更新噪点时间
    if (noiseRef.current && isChanging) {
      noiseRef.current.material.uniforms.time.value = clock.getElapsedTime();
    }

    // 根据滚动位置设置不同内容
    let newContent = 0;
    if (offset < 0.2) {
      newContent = 0; // 首页 - WHO3 介绍
    } else if (offset < 0.4) {
      newContent = 1; // 动画和着色器效果
    } else if (offset < 0.6) {
      newContent = 2; // 数据可视化
    } else if (offset < 0.8) {
      newContent = 3; // 3D互动体验
    } else {
      newContent = 4; // 联系我
    }

    // 检测内容变化
    if (content !== newContent) {
      startChannelChangeAnimation(newContent);
      setContent(newContent);
    }
  });

  return (
    <Screen {...props}>
      <PerspectiveCamera
        makeDefault
        manual
        aspect={1 / 1}
        position={[0, 0, 10]}
      />

      {/* 显示实际内容 - 不在切换状态时 */}
      {!isChanging && content === 0 && (
        // 首页内容 - WHO3介绍
        <>
          <color attach="background" args={['black']} />
          <ambientLight intensity={Math.PI / 2} />
          <pointLight decay={0} position={[10, 10, 10]} intensity={Math.PI} />
          <pointLight
            decay={0}
            position={[-10, -10, -10]}
            intensity={Math.PI}
          />

          <SpinningBox position={[-3.15, 1, 0]} scale={0.5} />

          <Text
            position={[-3.15, 1, 0]}
            fontSize={0.3}
            letterSpacing={-0.1}
            color={'#35cc00'}
            font="/Optician-Sans.woff"
            textAlign="center"
          >
            WHO3
          </Text>
        </>
      )}

      {!isChanging && content === 1 && (
        // 动画和着色器效果
        <>
          <color attach="background" args={['#ff8888']} />
          <ambientLight intensity={Math.PI / 2} />
          <ShaderContent />
          <Text
            position={[-3.15, 0.75, 0]}
            fontSize={0.2}
            letterSpacing={-0.05}
            color={'#ff0'}
            font="/Optician-Sans.woff"
            textAlign="center"
          >
            SHADER EFFECTS
          </Text>
        </>
      )}

      {!isChanging && content === 2 && (
        // 数据可视化
        <>
          <color attach="background" args={['#001133']} />
          <ambientLight intensity={Math.PI / 2} />
          <DataVisualization />
          <Text
            position={[-3.15, 0.95, 0]}
            fontSize={0.2}
            letterSpacing={-0.05}
            color={'#00ffcc'}
            font="/Optician-Sans.woff"
            textAlign="center"
          >
            DATA VISUALIZATION
          </Text>
        </>
      )}

      {!isChanging && content === 3 && (
        // 3D互动体验
        <>
          <color attach="background" args={['#220033']} />
          <ambientLight intensity={Math.PI / 2} />
          <Interactive3D />
          <Text
            position={[-3.15, 0.75, 0]}
            fontSize={0.2}
            letterSpacing={-0.1}
            color={'#ffaa00'}
            font="/Optician-Sans.woff"
            textAlign="center"
          >
            3D EXPERIENCE
          </Text>
        </>
      )}

      {!isChanging && content === 4 && (
        // 联系我
        <>
          <color attach="background" args={['#003322']} />
          <ambientLight intensity={Math.PI / 2} />
          <ContactVisual />
          <Text
            position={[-3.15, 0.75, 0]}
            fontSize={0.3}
            letterSpacing={-0.05}
            color={'white'}
            font="/Optician-Sans.woff"
            textAlign="center"
          >
            CONTACT ME
          </Text>
        </>
      )}

      {/* 电视切换效果动画层 */}
      {isChanging && (
        <>
          <color attach="background" args={['#000000']} />
          <mesh ref={noiseRef} position={[-3.15, 0.75, 0]}>
            <planeGeometry args={[2.5, 2]} />
            <primitive object={noiseMaterial} attach="material" />
          </mesh>

          {/* 添加随机扫描线效果 */}
          <TVScanEffect />

          {/* 添加通道切换指示 */}
          <Text
            position={[-3.15, 0.35, 0]}
            fontSize={0.12}
            letterSpacing={0}
            color={'#5aff5a'}
            font="/Optician-Sans.woff"
            textAlign="center"
            maxWidth={2}
            lineHeight={1}
            anchorX="center"
            anchorY="middle"
            outlineWidth={0.02}
            outlineColor={'#003300'}
            overflowWrap="normal"
          >
            {`CHANNEL ${content + 1}`}
          </Text>
        </>
      )}
    </Screen>
  );
}

// 电视扫描线效果组件
function TVScanEffect() {
  const scanRef = useRef();

  useFrame(({ clock }) => {
    if (scanRef.current) {
      // 移动扫描线
      const time = clock.getElapsedTime();
      scanRef.current.position.y = 0.75 + Math.sin(time * 2) * 0.8;

      // 调整扫描线的不透明度
      if (scanRef.current.material) {
        scanRef.current.material.opacity = 0.1 + Math.sin(time * 5) * 0.05;
      }
    }
  });

  return (
    <mesh ref={scanRef} position={[-3.15, 0.75, 0.01]} rotation={[0, 0, 0]}>
      <planeGeometry args={[2.5, 0.05]} />
      <meshBasicMaterial color="#5aff5a" opacity={0.15} transparent={true} />
    </mesh>
  );
}

// 着色器效果视觉组件
function ShaderContent() {
  const mesh = useRef();

  // 使用时间来动画化网格变形
  useFrame(({ clock }) => {
    if (mesh.current) {
      mesh.current.rotation.x = Math.sin(clock.getElapsedTime()) * 0.3;
      mesh.current.rotation.y = Math.sin(clock.getElapsedTime() * 0.8) * 0.5;
      mesh.current.scale.x = 1 + Math.sin(clock.getElapsedTime()) * 0.2;
      mesh.current.scale.y = 1 + Math.cos(clock.getElapsedTime()) * 0.2;
    }
  });

  return (
    <mesh ref={mesh} position={[-3.15, 0.75, 0]}>
      <torusKnotGeometry args={[0.5, 0.15, 64, 16]} />
      <meshStandardMaterial
        color="#e33344"
        emissive="#dd0011"
        wireframe={true}
      />
    </mesh>
  );
}

// 数据可视化组件
function DataVisualization() {
  const bars = useRef([]);
  const barCount = 12;

  // 创建柱状图的动画
  useFrame(({ clock }) => {
    const time = clock.getElapsedTime();
    bars.current.forEach((bar, i) => {
      if (bar) {
        const height = Math.abs(Math.sin(time * 0.5 + i * 0.2) * 2 + 0.5);
        bar.scale.y = height;
        bar.position.y = height / 2 - 1;
      }
    });
  });

  return (
    <group position={[-3.15, 0.75, 0]}>
      {Array.from({ length: barCount }).map((_, i) => (
        <mesh
          key={i}
          ref={(el) => (bars.current[i] = el)}
          position={[(i - barCount / 2) * 0.25, 0, 0]}
        >
          <boxGeometry args={[0.1, 1, 0.3]} />
          <meshStandardMaterial
            color={`hsl(${i * 40 + 200}, 100%, 70%)`}
            emissive={`hsl(${i * 40 + 150}, 100%, 30%)`}
          />
        </mesh>
      ))}
    </group>
  );
}

// 3D互动体验视觉组件
function Interactive3D() {
  const group = useRef();

  useFrame(({ clock }) => {
    if (group.current) {
      group.current.rotation.y = clock.getElapsedTime() * 0.2;
    }
  });

  return (
    <group ref={group} position={[-3.15, 0.75, 0]}>
      {Array.from({ length: 8 }).map((_, i) => (
        <mesh
          key={i}
          position={[
            Math.sin((i / 8) * Math.PI * 2) * 0.9,
            Math.cos((i / 8) * Math.PI * 2) * 0.9,
            0,
          ]}
          scale={0.4}
        >
          <icosahedronGeometry />
          <meshStandardMaterial
            color={`hsl(${i * 15}, 100%, 70%)`}
            emissive={`hsl(${i * 45}, 75%, 20%)`}
          />
        </mesh>
      ))}
    </group>
  );
}

// 联系我视觉组件
function ContactVisual() {
  const group = useRef();

  useFrame(({ clock }) => {
    if (group.current) {
      group.current.rotation.y = Math.sin(clock.getElapsedTime() * 0.5) * 0.5;
      group.current.rotation.x = Math.cos(clock.getElapsedTime() * 0.3) * 0.2;
    }
  });

  return (
    <group ref={group}>
      <mesh>
        <sphereGeometry args={[1.2, 32, 32]} />
        <meshStandardMaterial
          color="#003322"
          wireframe={true}
          emissive="#00ffaa"
          emissiveIntensity={0.5}
        />
      </mesh>
      <mesh scale={0.3} position={[0, 0, 1.2]}>
        <boxGeometry />
        <meshStandardMaterial color="#00ffaa" />
      </mesh>
    </group>
  );
}

// Renders flashing LED's
function Leds({ instances }) {
  const ref = useRef();
  const { nodes } = useGLTF('/models/computers_1-transformed.glb');
  useMemo(() => {
    nodes.Sphere.material = new THREE.MeshBasicMaterial();
    nodes.Sphere.material.toneMapped = false;
  }, [nodes.Sphere]);
  useFrame((state) => {
    ref.current.children.forEach((instance) => {
      const rand = Math.abs(2 + instance.position.x);
      const t = Math.round(
        (1 + Math.sin(rand * 10000 + state.clock.elapsedTime * rand)) / 2,
      );
      instance.color.setRGB(0, t * 1.1, t);
    });
  });
  return (
    <group ref={ref}>
      <instances.Sphere
        position={[-0.41, 1.1, -2.21]}
        scale={0.005}
        color={[1, 2, 1]}
      />
      <instances.Sphere
        position={[0.59, 1.32, -2.22]}
        scale={0.005}
        color={[1, 2, 1]}
      />
      <instances.Sphere
        position={[1.77, 1.91, -1.17]}
        scale={0.005}
        color={[1, 2, 1]}
      />
      <instances.Sphere
        position={[2.44, 1.1, -0.79]}
        scale={0.005}
        color={[1, 2, 1]}
      />
      <instances.Sphere
        position={[4.87, 3.8, -0.1]}
        scale={0.005}
        color={[1, 2, 1]}
      />
      <instances.Sphere
        position={[1.93, 3.8, -3.69]}
        scale={0.005}
        color={[1, 2, 1]}
      />
      <instances.Sphere
        position={[-2.35, 3.8, -3.48]}
        scale={0.005}
        color={[1, 2, 1]}
      />
      <instances.Sphere
        position={[-4.71, 4.59, -1.81]}
        scale={0.005}
        color={[1, 2, 1]}
      />
      <instances.Sphere
        position={[-3.03, 2.85, 1.19]}
        scale={0.005}
        color={[1, 2, 1]}
      />
      <instances.Sphere
        position={[-1.21, 1.73, -1.49]}
        scale={0.005}
        color={[1, 2, 1]}
      />
    </group>
  );
}
